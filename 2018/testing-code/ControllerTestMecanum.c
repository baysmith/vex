#pragma config(Sensor, dgtl1,  bump,           sensorTouch)
#pragma config(Sensor, dgtl2,  tank,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  arcade,         sensorLEDtoVCC)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// void macnum(int threshold);

void tankControl(int leftStickChannel, int rightStickChannel, int threshold);
void arcadeControl(int leftRightChannel, int forwardBackChannel, int threshold);

task main()
{
        // The threshold is used to control the sensitivity of the analog sticks.
        // We ensure that we don't send a value which is too small to the motors.
        int threshold = 10;

        // The driving mode: tankControl (0) or arcadeControl (1) or macno (2) .
        int mode = 0;

        // Press this button to switch modes.
        int modeButton = Btn5U;

        while(true){
                // While the bump sensor is held down, activate the left motor
                //if(SensorValue[bump] == 1) {
                //	motor[leftMotor] = 127;
                //} else {
                //	motor[leftMotor] = 0;
                //}

                // Tank drive with thresholding.
                //
                // Superceded by the built-in tankControl() function.
                //
                //if (vexRT[Ch3] > threshold ||  vexRT[Ch3] < -threshold) {
                //	motor[leftMotor] = vexRT[Ch3];
                //}
                //if (vexRT[Ch2] > threshold || vexRT[Ch2] < -threshold) {
                //	motor[rightMotor] = vexRT[Ch2];
                //}

                if (vexRT[modeButton] == 1) {
                        // Mode change: Intentionally stop and sleep briefly.
                        motor[frontRight] = 0;
                        motor[backRight] = 0;
                        motor[frontLeft] = 0;
                        motor[backLeft] = 0;
                        sleep(500);
                        mode = 1 - mode;
                }

                if (mode == 0) {
                        // Tank drive with threshold.
                        tankControl(Ch2, Ch3, threshold); // Left joystick, OR
                        // tankControl(Ch2, Ch1, threshold); // Right joystick
                        SensorValue[tank] = 1;
                        SensorValue[arcade] = 0;
                } else if (mode == 1) {
                        // Single joystick drive with threshold.
                        arcadeControl(Ch4, Ch3, threshold); //left joystick, OR
                        // arcadeControl(Ch2, Ch1, threshold); // Right joystick
                        SensorValue[tank] = 0;
                        SensorValue[arcade] = 1;
                }

                else if (mode == 2) {
                        //  Mecanum  drive controll .
                        // macnum(threshold); // Left joystick, OR
                        // arcadeControl(Ch2, Ch1, threshold); // Right joystick
                }

                clearLCDLine(0);
                clearLCDLine(1);
                displayLCDNumber(0, 0, mode, 4);
                displayLCDNumber(1, 5, threshold, 4);

        } // end (while true)
} // end (task main)

void macnum(int threshold)
{
        //Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
        int X2 = 0, Y1 = 0, X1 = 0;
        //Loop Forever
        while(1 == 1)
        {
                //Create "deadzone" for Y1/Ch3
                if(abs(vexRT[Ch3]) > threshold)
                        Y1 = vexRT[Ch3];
                else
                        Y1 = 0;
                //Create "deadzone" for X1/Ch4
                if(abs(vexRT[Ch4]) > threshold)
                        X1 = vexRT[Ch4];
                else
                        X1 = 0;
                //Create "deadzone" for X2/Ch1
                if(abs(vexRT[Ch1]) > threshold)
                        X2 = vexRT[Ch1];
                else
                        X2 = 0;

                //Remote Control Commands
                motor[frontRight] = Y1 - X2 - X1;
                motor[backRight] =  Y1 - X2 + X1;
                motor[frontLeft] = Y1 + X2 + X1;
                motor[backLeft] =  Y1 + X2 - X1;
        }
}

void tankControl(int leftStickChannel, int rightStickChannel, int threshold){

        if(abs(vexRT[leftStickChannel]) > threshold)         // If the left joystick is greater than or less than the threshold:
        {
                motor[frontLeft]  = (vexRT[leftStickChannel]);   // Left Joystick Y value / 2.
                motor[backLeft]  = (vexRT[leftStickChannel]);
        }
        else                                    // If the left joystick is within the threshold:
        {
                motor[frontLeft]  = 0;                // Stop the left motor (cancel noise)
                motor[backLeft]  = 0;
        }

        if(abs(vexRT[rightStickChannel]) > threshold)         // If the right joystick is greater than or less than the threshold:
        {
                motor[frontRight] = (vexRT[rightStickChannel]);   // Right Joystick Y value / 2.
                motor[backRight] = (vexRT[rightStickChannel]);
        }
        else                                    // If the right joystick is within the threshold:
        {
                motor[frontRight] = 0;                // Stop the right motor (cancel noise)
                motor[backRight] = 0;
        }
}

void arcadeControl(int leftRightChannel, int forwardBackChannel, int threshold){

        int Xaxis = vexRT[leftRightChannel];
        int Yaxis = vexRT[forwardBackChannel];

        if((abs(Xaxis) > threshold) && (abs(Yaxis) > threshold) && (Yaxis > 0))
        {
                motor[frontRight] = (Yaxis - Xaxis);
                motor[backRight] = (Yaxis - Xaxis);
                motor[frontLeft] = (Yaxis + Xaxis);
                motor[backLeft] = (Yaxis + Xaxis);

        }
        // Backwards and swing turns: (both abs(X) and abs(Y) are above the threshold, and Y is NEGATIVE)
        else if((abs(Xaxis) > threshold) && (abs(Yaxis) > threshold) && (Yaxis < 0))
        {
                motor[frontRight] = (Yaxis + Xaxis);
                motor[backRight] = (Yaxis + Xaxis);
                motor[frontLeft] = (Yaxis - Xaxis);
                motor[backLeft] = (Yaxis - Xaxis);
        }
        // Turning in place: (abs(X) is above the threshold, abs(Y) is below the threshold)
        else if((abs(Xaxis) > threshold) && (abs(Yaxis) < threshold))
        {
                motor[frontRight] = (-1 * Xaxis);
                motor[backRight] = (-1 * Xaxis);
                motor[frontLeft] = Xaxis;
                motor[backLeft] = Xaxis;
        }
        // Standing still: (both abs(X) and abs(Y) are below the threshold)
        else
        {
                motor[frontRight] = 0;
                motor[backRight] = 0;
                motor[frontLeft] = 0;
                motor[backLeft] = 0;
        }
}
