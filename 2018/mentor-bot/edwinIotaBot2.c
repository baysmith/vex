#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backLeft,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           backRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port10,          center,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void clearEncoders() {
	nMotorEncoder[frontRight] = 0;
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[frontLeft] = 0;
}

void startMotors(int speed) {
	motor[backLeft] = speed;
}

void stopMotors() {
	motor[backLeft] = 0;
}

// Gets direction of vehicle, mostly dependent on if clickDistance is positive or negative
// 1 if going forward; -1 if going backwards; 0 if no transformation
int getDirection(int clickDistance, int initialSpeed) {
	if(clickDistance > 0) {
		return 1;
	}
	else if(clickDistance < 0) {
		return -1;
	}
	return 0;
}

int speedAfterDrift(int clickDistance, int initialSpeed) {
	int absEncoderValue = abs(nMotorEncoder[backLeft]);
	int absClickDistance = abs(clickDistance);
	int newSpeed;

	// If less than 90% complete, slow down motor to 75% speed
	if(absEncoderValue <= absClickDistance * 0.5) {
		newSpeed = initialSpeed;
	}
	// If 90% complete, slow down motor to 75% speed
	else if(absEncoderValue > absClickDistance * 0.8) {
		newSpeed = initialSpeed * 0.75;
	}
	// If 97% complete, slow down motor to 25% speed
	else if(absEncoderValue > absClickDistance * 0.90) {
		newSpeed = initialSpeed * 0.25;
	}
	// If overshoot
	else if(absEncoderValue > absClickDistance) {
		newSpeed = -initialSpeed * 0.25;
	}
	else {
		newSpeed = initialSpeed;
	}
	// newSpeed = correctInvalidSpeed(newSpeed);
	return newSpeed;
}

// Move robot straigh line dependent on click value
// Assuming initialSpeed is positive
int moveClicks(int clickDistance, int initialSpeed) {
	int direction = getDirection(clickDistance, initialSpeed);

	long newSpeed;
	if(direction == 1) {
		newSpeed = speedAfterDrift(clickDistance, initialSpeed);
		startMotors(newSpeed);
	}
	else if(direction == -1) {
		newSpeed = speedAfterDrift(clickDistance, -initialSpeed);
		startMotors(newSpeed);
	}
	else {
		stopMotors();
	}
	return newSpeed;
}

task main() {
	int globlal = 45;
	clearEncoders();

	int clickDistance = 1500;
	int initialSpeed = 127;
	while(true) {
		int newSpeed = moveClicks(clickDistance, initialSpeed);
		initialSpeed = newSpeed;
	}
}
