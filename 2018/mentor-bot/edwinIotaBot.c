#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backLeft,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           backRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port10,          center,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void clearEncoders() {
	nMotorEncoder[frontRight] = 0;
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[frontLeft] = 0;
}

void goStraight(int speed, int margin) {
	if(abs(nMotorEncoder[frontRight]) < abs(nMotorEncoder[backLeft])) {
			motor[frontRight] = speed;
			motor[frontLeft] = speed - margin;
			motor[backRight] = speed;
			motor[backLeft] = speed - margin;
	}
	else if (abs(nMotorEncoder[backLeft]) < abs(nMotorEncoder[frontRight])) {
		motor[frontRight] = speed - margin;
		motor[frontLeft] = speed;
		motor[backRight] = speed - margin;
		motor[backLeft] = speed;
	}
	else {
		motor[frontRight] = speed;
		motor[frontLeft] = speed;
		motor[backRight] = speed;
		motor[backLeft] = speed;
	}
}

task main() {
	clearEncoders();

	while(true) {
		goStraight(120, 50);
	}

}
