#pragma config(Sensor, dgtl1, DownButton, sensorTouch)
#pragma config(Sensor, dgtl2, RightButton, sensorTouch)
#pragma config(Sensor, dgtl3, UpButton, sensorTouch)
#pragma config(Sensor, dgtl4, LeftButton, sensorTouch)
#pragma config(Sensor, dgtl5, ShoulderEncoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl7, ElbowEncoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl9, WristEncoderA, sensorQuadEncoder)
#pragma config(Motor, port2, ShoulderMotor, tmotorVex269_MC29, openLoop)
#pragma config(Motor, port3, ElbowMotor, tmotorVex269_MC29, openLoop)
#pragma config(Motor, port4, WristMotor, tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*****************************************************************************
 * This program demonstrates the use of PID to control a 3-joint robotic arm *
 * with three degrees of freedom.                                            *
 *****************************************************************************/

#define MAX_PID_CONTROLLERS 4
float P[MAX_PID_CONTROLLERS];
float I[MAX_PID_CONTROLLERS];
float D[MAX_PID_CONTROLLERS];
float integrals[MAX_PID_CONTROLLERS];
float errors[MAX_PID_CONTROLLERS];

const float PI = 3.14159265;
const float RADIANS_TO_DEGREES = 180.0 / PI;

/**
 * Returns min if x < min, max if x > max, or x otherwise.
 */
float clamp(float x, float min, float max) {
    return (x < min ? min : (x > max ? max : x));
}

/**
 * If the setpoint changes drastically, we can end up with a condition called
 * "integral windup": The error becomes large due to the setpoint change, so
 * the integral term starts calculating huge values that cause our output to
 * overshoot...causing another large error term, another huge integral value,
 * another overshoot, and so on _ad infinitum._
 *
 * There are several practical ways to eliminate this, and one of them is to
 * simply cut the integral term when the error is too large.  Since our
 * outputs are motor speeds between -100 and 100, I'd say a fraction of that
 * interval seems reasonable.
 */
const float maxError = 0.2 * (100 - -100);

/**
 * Sets the PID constants for the Nth PID controller.
 *
 * @param n The index of the controller whose parameters you will be setting.
 *          Values outside of the closed interval [0, MAX_PID_CONTROLLERS - 1]
 *          will be ignored.
 * @param kP Proportional constant.  Used to provide a large amount of power
 *           when there's a long way to go, and a small amount of power as the
 *           measurement gets closer to the setpoint.
 *           (You should probably always have this.)
 * @param kI Integral constant.  Used to slowly increase output power when the
 *           power from the proportional output becomes too small.  Usually
 *           very small compared to kP; set to 0 if you don't need it.
 * @param kD Derivative constant.  Used to slow down if the rate of change in
 *           the error is too fast.  Use 0 if you don't need it.
 *           (I'd suggest setting this before you give kI a nonzero value.)
 */
void setPID(int n, float kP, float kI, float kD) {
    if (n >= 0 && n < MAX_PID_CONTROLLERS) {
        P[n] = kP;
        I[n] = kI;
        D[n] = kD;
        integrals[n] = 0;
        errors[n] = 0;
    }
}

/**
 * Calculates the next output from the PID controller.  The power of the
 * output depends entirely on the constants that you passed into setPID()
 * earlier.
 *
 * @param n       The index of the controller to use.  Values outside of
 *                the closed interval [0, MAX_PID_CONTROLLERS - 1] will be
 *                ignored.
 * @param measurement The current measurement for the sensor that you are
 *                    using for PID control.  This could be a gyro or
 *                    potentiometer angle, a distance measurement, a flywheel
 *                    angular velocity, and so on.
 * @param setpoint    Where you want the measurement to be before we stop
 *                    applying power.
 * @return            Returns the power that your system should be applying
 *                    next in order to get your measurement closer to the
 *                    setpoint.  This is usually a motor speed.
 */
float calculate(int n, float measurement, float setpoint) {
    if (n < 0 || n >= MAX_PID_CONTROLLERS) {
        return 0;
    }

    // These PID calculations are somewhat unusual for ignoring dt (the time
    // delta); this follows advice from
    // https://georgegillard.com/resources/documents and works well in practice
    // with the only consequence being that the intermediate integral and
    // derivative calculations are larger, necessitating the use of smaller
    // values for your I and D constants.
    float error = setpoint - measurement;
    float integral = integrals[n] + error;
    if (abs(error) > maxError) {
        // Avoid integral windup: let the P term get closer before we apply an I
        // term.
        integral = 0;
    }
    float previousError = errors[n];
    float derivative = error - previousError;
    float outputPower = error * P[n] + integral * I[n] + derivative * D[n];

    integrals[n] = integral;
    errors[n] = error;

    return outputPower;
}

enum jointIndices {
    shoulder,
    elbow,
    wrist
};
struct jointAngles {
    float shoulderAngle, elbowAngle, wristAngle;
};

const int SHOULDER_ENCODER_CLICKS_AT_HORIZONTAL = 80; // Confirmed (with shaft bug fixed)
const int SHOULDER_ENCODER_CLICKS_AT_VERTICAL = -6;   // Confirmed (with shaft bug fixed)
const int ELBOW_ENCODER_CLICKS_AT_HORIZONTAL = 94;    // Confirmed
const int ELBOW_ENCODER_CLICKS_AT_VERTICAL = 8;       // Confirmed
const int WRIST_ENCODER_CLICKS_AT_HORIZONTAL = 0;     // Confirmed
const int WRIST_ENCODER_CLICKS_AT_VERTICAL = -80;     // Confirmed

// If the power that the calculate() function tells us to use is lower than
// this, don't bother moving.  I do hate hearing the high-pitched whine that
// results when we tell a 269 or 393 motor to move too slowly.
const int MIN_MOTOR_POWER = 23;

// The VEX Optical Shaft Encoder is nominally 360 clicks per revolution (see
// https://renegaderobotics.org/vex-sensors-shaft-encoders/), so this value
// _ought_ to be 1.  In practice it varies slightly due to dust, hence the
// need for multiple constants.
//
// They can be cleaned out, by the way:
// - https://www.vexforum.com/t/optical-encoder-failure-mode-self-made-dust/26404/8
const float shoulderDegreesPerEncoderClick = abs(90.0 / (SHOULDER_ENCODER_CLICKS_AT_HORIZONTAL - SHOULDER_ENCODER_CLICKS_AT_VERTICAL));
const float elbowDegreesPerEncoderClick = abs(90.0 / (ELBOW_ENCODER_CLICKS_AT_HORIZONTAL - ELBOW_ENCODER_CLICKS_AT_VERTICAL));
const float wristDegreesPerEncoderClick = abs(90.0 / (WRIST_ENCODER_CLICKS_AT_HORIZONTAL - WRIST_ENCODER_CLICKS_AT_VERTICAL));

// Limb measurements for the arm (L1 and L2 in the kinematics equation.)
// These must be accurately measured or else the X and Y calculations will be
// off.
const float forearmLengthInches = 5.0;  // Confirmed
const float upperArmLengthInches = 6.0; // Confirmed

// The debugger can't show local variables (apparently?), but it can show the
// value of global ones.  So any variable here is significant for debugging.
float shoulderPower = 0, shoulderAngle = 0,
      elbowPower = 0, elbowAngle = 0,
      wristPower = 0, wristAngle = 0,
      debugAngle = 0;

// NOTE: All values here are assumed to be 0 degrees at vertical (except for
// yInches, the vertical extent).  Aim the arm straight up before starting the
// program.
float initialShoulderDegrees = 0,
      initialElbowDegrees = 0,
      initialWristDegrees = 0,
      xInches = 0,
      yInches = forearmLengthInches + upperArmLengthInches;

/**
 * Returns the relative angle of the given joint, in degrees.  You choose what "relative" means.
 *
 * This function relies on accurate values for the `*_CLICKS_AT_HORIZONTAL` and
 * `*_CLICKS_AT_VERTICAL` constants.  VEX encoders can gather dust over the
 * years which affects their results differently; you must take the measurements!
 *
 * @param jointIndex One of shoulder, elbow, or wrist.
 * @param reset      If true, we will record the initial angle for this joint
 *                   and return 0; if false, we will return the current angle
 *                   for this joint.
 * @return           Returns 0 if reset==true, and a (hopefully accurate)
 *                   angle relative to the last reset otherwise.
 *
 */
float getDegrees(int jointIndex, bool reset) {
    // Obtain approximate angle measures from the quadrature encoders.
    float shoulderDegrees = SensorValue[ShoulderEncoderA] * shoulderDegreesPerEncoderClick;
    float elbowDegrees = SensorValue[ElbowEncoderA] * elbowDegreesPerEncoderClick;
    float wristDegrees = SensorValue[WristEncoderA] * wristDegreesPerEncoderClick;

    switch (jointIndex) {
    case shoulder:
        if (reset) {
            initialShoulderDegrees = shoulderDegrees;
        }
        return shoulderDegrees - initialShoulderDegrees;
    case elbow:
        if (reset) {
              // Because the elbow is *supposed* to be at 180 degrees when the arm is fully vertical,
            // but its actual measured angle is 0 after the encoder reset, we need to add to the measured
            // value to make it line up with our math.
            initialElbowDegrees = elbowDegrees - 180;
        }
        return elbowDegrees - initialElbowDegrees;
    case wrist:
        if (reset) {
            initialWristDegrees = wristDegrees;
        }
        return wristDegrees - initialWristDegrees;
    }

    // Control shouldn't make it here.
    return 0;
}

/**
 * Attempts to position the robot arm using trigonometry and PID.
 *
 * This function updates xInches and yInches as a side effect.  As a special use case,
 * if up, down, left, and right are all true simultaneously (i.e., the user hit all
 * four buttons at once), the entire robot arm attempts to return to home position.
 *
 * @param jointIndex One of shoulder, elbow, or wrist.
 * @param up         True if the up button is being pressed and false if it is not.
 * @param down       True if the down button is being pressed and false if it is not.
 * @param left       True if the left button is being pressed and false if it is not.
 * @param right      True if the right button is being pressed and false if it is not.
 * @param result     A data structure that we will use to store our three output angles.
 */
void robotArmMode(bool up, bool down, bool left, bool right, jointAngles *result) {
    // How much the buttons move the X and Y values for the arm.
    const float armIncrementInches = 0.1;

    float newX = xInches, newY = yInches;

    if (down && up && left && right) {

        // The user pressed all four buttons at once.  Reset to our starting position.
        newX = 0;
        newY = forearmLengthInches + upperArmLengthInches;
    } else {

        // Normal controls.
        if (down) {
            newY = yInches - armIncrementInches;
        }
        if (up) {
            newY = yInches + armIncrementInches;
        }
        if (left) {
            newX = xInches - armIncrementInches;
        }
        if (right) {
            newX = xInches + armIncrementInches;
        }
    }

    float h = sqrt(newX * newX + newY * newY);
    if (h < fabs(forearmLengthInches - upperArmLengthInches) || // Elbow squeezed too tightly
        h > forearmLengthInches + upperArmLengthInches ||       // Arm stretched too far
        newY < 0 ||                                             // The arm is dipping too far down
        newX < 0) {                                             // The arm is going backward
        // New arm position is illegal.  Ignore!
        newX = xInches;
        newY = yInches;
        h = sqrt(newX * newX + newY * newY);
    } else {
        // Commit the changes to memory.
        xInches = newX;
        yInches = newY;
    }

    // Calculate trig constants (all values are in radians.)
    float gamma = acos((h * h - forearmLengthInches * forearmLengthInches - upperArmLengthInches * upperArmLengthInches) /
                       (-2 * forearmLengthInches * upperArmLengthInches));
    float alpha = asin(forearmLengthInches * sin(gamma) / h);
    float beta = PI - alpha - gamma;
    float theta = asin(newY / h);
    float phi = asin(newX / h);

    // 0 degrees (as calculated by the inverse kinematics formula) for
    // the shoulder and elbow must be vertical.
    float newShoulderAngle = (alpha + theta) * RADIANS_TO_DEGREES - 90;
    float newElbowAngle = gamma * RADIANS_TO_DEGREES;

    // The wrist must always face forward.
    float newWristAngle = (beta + phi) * RADIANS_TO_DEGREES;

    result->shoulderAngle = newShoulderAngle;
    result->elbowAngle = newElbowAngle;
    result->wristAngle = newWristAngle;
}

/**
 * PID tuning is hard.  This function helps me by specifically adjusting the angle of a single joint.
 * This allows me to observe the current angle, output power, and error terms to see if the PID for the
 * joint is tuned correctly, independent of the other joints.
 *
 * As a special use case, if up and down are true at the same time (because the user hit both of those
 * buttons at once), the joint will move to its zero-position.
 *
 * @param jointIndex The joint you are debugging.  One of shoulder, elbow, or wrist.
 * @param up         True if the up button is being pressed and false if it is not.
 * @param down       True if the down button is being pressed and false if it is not.
 * @param result     A data structure that we will use to *one* of the three output angles
 *                   (namely, the one you are debugging.)  The other two will be set to 0.
 */
void pidDebuggingMode(int jointIndex, bool up, bool down, jointAngles *result) {

    const float angleIncrementDegrees = 1.0;

    if (up && down) {
        debugAngle = 0;
    } else if (up) {
        debugAngle = clamp(debugAngle + angleIncrementDegrees, 0, 90);
    } else if (down) {
        debugAngle = clamp(debugAngle - angleIncrementDegrees, 0, 90);
    }

    result->shoulderAngle = result->elbowAngle = result->wristAngle = 0;

    switch (jointIndex) {
    case shoulder:
        result->shoulderAngle = debugAngle;
        break;
    case elbow:
        result->elbowAngle = debugAngle;
        break;
    case wrist:
        result->wristAngle = debugAngle;
        break;
    }
}

task main() {
    // Reset all joint angles.
    getDegrees(shoulder, true);
    getDegrees(elbow, true);
    getDegrees(wrist, true);

    // TODO: Determine these constants.
    // Start with the wrist; it's the lightest and problems with it will do the
    // least harm.
    setPID(shoulder, 8.000, 0.000, 13.500);
    setPID(elbow, 2.300, 0.000, 7.000);
    // setPID(elbow,    1.500, 0.000, 1.600);  // The elbow needs more oomph than the wrist
    // setPID(wrist,    1.200, 0.000, 1.250); // Not bad!
    setPID(wrist, 2.000, 0.000, 4.600);

    // Version 2 of the robot arm: all movements are controlled using PID.  We
    // determine two values: X, which is the desired extent outward, and Y,
    // which is the desired vertical extent, and rotate the shoulder and arm
    // motors to make the wrist position reach (x, y).  The wrist itself,
    // meanwhile, is forced to constantly point at a horizontal angle.
    //
    // The up and down buttons control Y, and the left and right buttons
    // control X.
    while (1) {
        jointAngles result;
        robotArmMode(SensorValue[UpButton], SensorValue[DownButton], SensorValue[LeftButton], SensorValue[RightButton], &result);
        // pidDebuggingMode(wrist, SensorValue[UpButton], SensorValue[DownButton], &result);

        // Obtain relative arm angles.
        shoulderAngle = getDegrees(shoulder, false);
        elbowAngle = getDegrees(elbow, false);
        wristAngle = getDegrees(wrist, false);

        // Move according to the velocity.
        shoulderPower = calculate(shoulder, shoulderAngle, result.shoulderAngle);
        elbowPower = calculate(elbow, elbowAngle, result.elbowAngle);
        wristPower = calculate(wrist, wristAngle, result.wristAngle);



        motor[ShoulderMotor] = abs(shoulderPower) < MIN_MOTOR_POWER ? 0 : clamp(shoulderPower, -100, 100);
        motor[ElbowMotor] = abs(elbowPower) < MIN_MOTOR_POWER ? 0 : clamp(elbowPower, -100, 100);
        motor[WristMotor] = abs(wristPower) < MIN_MOTOR_POWER ? 0 : clamp(wristPower, -100, 100);

        // Let's be reasonable about those X and Y increment speeds.
        sleep(20);
    }
}
