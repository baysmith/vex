#pragma config(Sensor, dgtl1,  DownButton,     sensorTouch)
#pragma config(Sensor, dgtl2,  RightButton,    sensorTouch)
#pragma config(Sensor, dgtl3,  UpButton,       sensorTouch)
#pragma config(Sensor, dgtl4,  LeftButton,     sensorTouch)
#pragma config(Sensor, dgtl5,  ShoulderEncoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ElbowEncoderA,  sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  WristEncoderA,  sensorQuadEncoder)
#pragma config(Motor,  port2,           ShoulderMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ElbowMotor,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           WristMotor,    tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#define MAX_PID_CONTROLLERS 10
float P[MAX_PID_CONTROLLERS];
float I[MAX_PID_CONTROLLERS];
float D[MAX_PID_CONTROLLERS];
float integrals[MAX_PID_CONTROLLERS];
float errors[MAX_PID_CONTROLLERS];

const float PI = 3.14159265;
const float RADIANS_TO_DEGREES = 180.0 / PI;

/**
 * Returns min if x < min, max if x > max, or x otherwise.
 */
float clamp(float x, float min, float max) {
  return (x < min ? min : x > max ? max : x);
}

/**
 * If the setpoint changes drastically, we can end up with a condition called
 * "integral windup": The error becomes large due to the setpoint change, so
 * the integral term starts calculating huge values that cause our output to
 * overshoot...causing another large error term, another huge integral value,
 * another overshoot, and so an _ad infinitum._
 *
 * There are several practical ways to eliminate this, and one of them is to
 * simply cut the integral term when the error is too large.  Since our
 * outputs are motor speeds between -100 and 100, I'd say a fraction of that
 * interval seems reasonable.
 */
const float maxError = 0.2 * (100 - -100);

/**
 * Sets the PID constants for the Nth PID controller.
 *
 * @param n The index of the controller whose parameters you will be setting.
 *          Values outside of the closed interval [0, MAX_PID_CONTROLLERS - 1]
 *          will be ignored.
 * @param kP Proportional constant.  Used to provide a large amount of power
 *           when there's a long way to go, and a small amount of power as the
 *           measurement gets closer to the setpoint.
 *           (You should probably always have this.)
 * @param kI Integral constant.  Used to slowly increase output power when the
 *           power from the proportional output becomes too small.  Usually
 *           very small compared to kP; set to 0 if you don't need it.
 * @param kD Derivative constant.  Used to slow down if the rate of change in
 *           the error is too fast.  Use 0 if you don't need it.
 *           (I'd suggest setting this before you give kI a nonzero value.)
 */
void setPID(int n, float kP, float kI, float kD) {
  if (n >= 0 && n < MAX_PID_CONTROLLERS) {
    P[n] = kP;
    I[n] = kI;
    D[n] = kD;
    integrals[n] = 0;
    errors[n] = 0;
  }
}

/**
 * Calculates the next output from the PID controller.  The power of the
 * output depends entirely on the constants that you passed into setPID()
 * earlier.
 *
 * @param n   The index of the controller to use.  Values outside of
 *            the closed interval [0, MAX_PID_CONTROLLERS - 1] will be
 *            ignored.
 * @param measurement The current measurement for the sensor that you are
 *            using for PID control.  This could be a gyro or
 *            potentiometer angle, a distance measurement, a flywheel
 *            angular velocity, and so on.
 * @param setpoint    Where you want the measurement to be before we stop
 *            applying power.
 * @return            Returns the power that your system should be applying
 *            next.  This is usually a motor speed.
 */
float calculate(int n, float measurement, float setpoint) {
  if (n < 0 || n >= MAX_PID_CONTROLLERS) {
    return 0;
  }

  float error = setpoint - measurement;
  float integral = integrals[n] + error;
  if (abs(error) > maxError) {
    // Avoid integral windup: let the P term get closer before we apply an I
    // term.
    integral = 0;
  }
  float previousError = errors[n];
  float derivative = error - previousError;
  float outputPower = error * P[n] + integral * I[n] + derivative * D[n];

  integrals[n] = integral;
  errors[n] = error;

  return outputPower;
}

enum jointIndices { shoulder, elbow, wrist };

const int SHOULDER_ENCODER_CLICKS_AT_HORIZONTAL = -54; // Confirmed
const int SHOULDER_ENCODER_CLICKS_AT_VERTICAL = -8;   // Confirmed
const int ELBOW_ENCODER_CLICKS_AT_HORIZONTAL = -11;    // Confirmed
const int ELBOW_ENCODER_CLICKS_AT_VERTICAL = -96;      // Confirmed
const int WRIST_ENCODER_CLICKS_AT_HORIZONTAL = 0;      // Confirmed
const int WRIST_ENCODER_CLICKS_AT_VERTICAL = 78;       // Confirmed

// This is a rough approximation, but it should be the same for every
// quadrature encoder connected to an output shaft.
const float shoulderDegreesPerEncoderClick = abs(90.0 / (SHOULDER_ENCODER_CLICKS_AT_HORIZONTAL - SHOULDER_ENCODER_CLICKS_AT_VERTICAL));
const float elbowDegreesPerEncoderClick = abs(90.0 / (ELBOW_ENCODER_CLICKS_AT_HORIZONTAL - ELBOW_ENCODER_CLICKS_AT_VERTICAL));
const float wristDegreesPerEncoderClick = abs(90.0 / (WRIST_ENCODER_CLICKS_AT_HORIZONTAL - WRIST_ENCODER_CLICKS_AT_VERTICAL));

// Limb measurements for the arm (L1 and L2 in the kinematics equation.)
// These must be accurately measured, or the X and Y calculations will be off.
const float forearmLengthInches = 5.0;  // Confirmed
const float upperArmLengthInches = 6.0; // Confirmed

// The debugger can't show local variables, but it can show the value of global ones.  So any variable here
// is significant for debugging.
float shoulderPower = 0,
      elbowPower = 0,
      wristPower = 0;

// NOTE: All values here are assumed to be 0 degrees at vertical (except for
// yInches, the vertical extent).  Aim the arm straight up before starting the
// program.
float initialShoulderDegrees = 0, shoulderAngle = 0,
      initialElbowDegrees = 0, elbowAngle = 0,
      initialWristDegrees = 0, wristAngle = 0,
      xInches = 0,
      yInches = forearmLengthInches + upperArmLengthInches;

/**
 * Returns the relative angle of the given joint, in degrees.  You choose what "relative" means.
 *
 * This function relies on accurate values for the `*_CLICKS_AT_HORIZONTAL` and
 * `*_CLICKS_AT_VERTICAL` constants.  VEX encoders can gather dust over the
 * years which affects their results differently; you must take the measurements!
 *
 * @param jointIndex One of shoulder, elbow, or wrist.
 * @param reset      If true, we will record the initial angle for this joint
 *                   and return 0; if false, we will return the current angle
 *                   for this joint.
 * @return           Returns 0 if reset==true, and a (hopefully accurate)
 *                   angle relative to the last reset otherwise.
 *
 */
float getDegrees(int jointIndex, bool reset) {
	// Obtain angle measures from the quadrature encoders.
  float shoulderDegrees = SensorValue[ShoulderEncoderA] * shoulderDegreesPerEncoderClick;
  float elbowDegrees = SensorValue[ElbowEncoderA] * elbowDegreesPerEncoderClick;
  float wristDegrees = SensorValue[WristEncoderA] * wristDegreesPerEncoderClick;

	switch(jointIndex) {
		case shoulder:
		  if (reset) {
		  	initialShoulderDegrees = shoulderDegrees;
		  	return 0;
		  } else {
		    return shoulderDegrees - initialShoulderDegrees;
		  }
		  break;
		case elbow:
		  if (reset) {
		  	initialElbowDegrees = elbowDegrees;
		  	return 0;
		  } else {
		  	return elbowDegrees - initialElbowDegrees;
		  }
		  break;
	  case wrist:
	    if (reset) {
	    	initialWristDegrees = wristDegrees;
	    	return 0;
	    } else {
	      return wristDegrees - initialWristDegrees;
	    }
	}

	// Control shouldn't make it here.
	return 0;
}

float h=0;
// How much the buttons move the X and Y values for the arm.
const float armIncrementInches = 1.0;

task main()
{
    // Reset all joint angles.
    getDegrees(shoulder, true);
    getDegrees(elbow, true);
    getDegrees(wrist, true);

    // TODO: Determine these constants.
    // Start with the wrist; it's the lightest and problems with it will do the
    // least harm.
    setPID(shoulder, 0.000, 0.000, 0.000);
    setPID(elbow,    0.000, 0.000, 0.000);
    setPID(wrist,    0.000, 0.000, 0.000);

    // Version 2 of the robot arm: all movements are controlled using
    // PID.  We determine two values: X, which is the desired extent
    // outward, and Y, which is the desired vertical extent, and rotate
    // the shoulder and arm motors to reach (x, y).  The wrist, meanwhile,
    // is forced to constantly point at a horizontal angle.
    //
    // The up and down buttons control Y, and the left and right buttons
    // control X.
    while (1) {
        float newX = xInches, newY = yInches;

        if (SensorValue[DownButton]) {
            newY = yInches - armIncrementInches;
        }

        if (SensorValue[UpButton]) {
            newY = yInches + armIncrementInches;
        }

        if (SensorValue[LeftButton]) {
            newX = xInches - armIncrementInches;
        }

        if (SensorValue[RightButton]) {
            newX = xInches + armIncrementInches;
        }

        h = sqrt(newX * newX + newY * newY);
        if (h < fabs(forearmLengthInches - upperArmLengthInches) ||
            h > forearmLengthInches + upperArmLengthInches) {
            // You've stretched too far or squeezed the elbow too tight; ignore!
            newX = xInches;
            newY = yInches;
            h = sqrt(newX * newX + newY * newY);
        } else {
            // Commit the changes to memory.
            xInches = newX;
            yInches = newY;
        }

        // Calculate trig constants (all values are in radians.)
        float gamma = acos((h * h - forearmLengthInches * forearmLengthInches - upperArmLengthInches * upperArmLengthInches) /
                   (-2 * forearmLengthInches * upperArmLengthInches));
        float alpha = asin(forearmLengthInches * sin(gamma) / h);
        float beta = PI - alpha - gamma;
        float theta = asin(newY / h);
        float phi = asin(newX / h);

        // 0 degrees for the shoulder and elbow must be vertical.
        float newShoulderAngle = (alpha + theta) * RADIANS_TO_DEGREES - 90;
        float newElbowAngle = 180 - gamma * RADIANS_TO_DEGREES;

        // The wrist must always face forward.
        float newWristAngle = (beta + phi) * RADIANS_TO_DEGREES + 90;

        // Obtain relative arm angles.
        shoulderAngle = getDegrees(shoulder, false);
        elbowAngle = getDegrees(elbow, false);
        wristAngle = getDegrees(wrist, false);

        // Move according to the velocity.
        shoulderPower = calculate(shoulder, shoulderAngle, newShoulderAngle);
        elbowPower = calculate(elbow, elbowAngle, newElbowAngle);
        wristPower = calculate(wrist, wristAngle, newWristAngle);

        motor[ShoulderMotor] = shoulderPower;
        motor[ElbowMotor] = elbowPower;
        motor[WristMotor] = wristPower;
      }
}
