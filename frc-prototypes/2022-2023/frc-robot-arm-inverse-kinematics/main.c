#pragma config(Sensor, dgtl1,  DownButton,     sensorTouch)
#pragma config(Sensor, dgtl2,  RightButton,    sensorTouch)
#pragma config(Sensor, dgtl3,  UpButton,       sensorTouch)
#pragma config(Sensor, dgtl4,  LeftButton,     sensorTouch)
#pragma config(Sensor, dgtl5,  ShoulderEncoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ElbowEncoderA,  sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  WristEncoderA,  sensorQuadEncoder)
#pragma config(Motor,  port2,           ShoulderMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ElbowMotor,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           WristMotor,    tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

enum motorIndices {
	shoulderIndex393,
	elbowIndex269,
	wristIndex269,
	MAX_ARM_MOTORS
};

const int SHOULDER_ENCODER_MEASURE_AT_HORIZONTAL = 26;
const int SHOULDER_ENCODER_MEASURE_AT_VERTICAL = 0;

// This is a rough approximation, but it should be the same for every
// quadrature encoder connected to an output shaft.
const float degreesPerEncoderClick = 90.0 / (SHOULDER_ENCODER_MEASURE_AT_HORIZONTAL - SHOULDER_ENCODER_MEASURE_AT_VERTICAL);

// The debugger can't show local variables, but it can show the value of global ones.  So any variable here
// is significant for debugging.
float velocity[] = { 0, 0, 0 };

// NOTE: All values here are assumed to be 0 degrees at vertical.  Aim the arm straight up before
// starting the program.
float shoulderDegrees = 0,
      elbowDegrees = 0;

task main()
{

	const float acceleration[] = { 0.03, 0.03, 0.03 };
	const float maxVelocity[] = { 35, 75, 75 };
	const float velocityDecayFactor[] = { 0.9993, 0.9993, 0.9993 };
	int i;

	// Version 1 of the robot arm: just moves the shoulder motor in a straightforward way, no
	// PID involved.
	while (true) {
		if (SensorValue[DownButton]) {
			velocity[shoulderIndex393] += acceleration[shoulderIndex393];
		}

		if (SensorValue[UpButton]) {
			velocity[shoulderIndex393] -= acceleration[shoulderIndex393];
		}

		if (SensorValue[LeftButton]) {
			velocity[elbowIndex269] += acceleration[elbowIndex269];
		}

		if (SensorValue[RightButton]) {
			velocity[elbowIndex269] -= acceleration[elbowIndex269];
		}

		// Clamp all velocities to [-max, +max].
		for (i = 0; i < MAX_ARM_MOTORS; i++) {
		  if (velocity[i] > maxVelocity[i]) {
			  velocity[i] = maxVelocity[i];
		  } else if (velocity[i] < -maxVelocity[i]) {
			  velocity[i] = -maxVelocity[i];
		  }
		}

		// Move according to the velocity.
		motor[ShoulderMotor] = (int)velocity[shoulderIndex393];
		// motor[ElbowMotor] = (int)velocity[elbowIndex269];
		// motor[WristMotor] = (int)velocity[wristIndex269];
		motor[WristMotor] = (int)velocity[elbowIndex269];

		// Decay the velocity over time.
		for (i = 0; i < MAX_ARM_MOTORS; i++) {
		  velocity[i] *= velocityDecayFactor[i];
	  }

	  // Update angle measures.
	  shoulderDegrees = SensorValue[ShoulderEncoderA] * degreesPerEncoderClick;
	  elbowDegrees = SensorValue[ElbowEncoderA] * degreesPerEncoderClick;
	}
}
