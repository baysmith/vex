#pragma config(Sensor, dgtl1,  DownButton,     sensorTouch)
#pragma config(Sensor, dgtl2,  RightButton,    sensorTouch)
#pragma config(Sensor, dgtl3,  UpButton,       sensorTouch)
#pragma config(Sensor, dgtl4,  LeftButton,     sensorTouch)
#pragma config(Sensor, dgtl5,  ShoulderEncoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ElbowEncoderA,  sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  WristEncoderA,  sensorQuadEncoder)
#pragma config(Motor,  port2,           ShoulderMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ElbowMotor,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           WristMotor,    tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#define MAX_PID_CONTROLLERS 10
float P[MAX_PID_CONTROLLERS];
float I[MAX_PID_CONTROLLERS];
float D[MAX_PID_CONTROLLERS];
float integrals[MAX_PID_CONTROLLERS];
float errors[MAX_PID_CONTROLLERS];

/**
 * Returns min if x < min, max if x > max, or x otherwise.
 */
float clamp(float x, float min, float max) {
  return (x < min ? min : x > max ? max : x);
}

const float PI = 3.14159265;
const float DEGREES_TO_RADIANS = PI / 180.0;
const float RADIANS_TO_DEGREES = 180.0 / PI;

/**
 * The amount of time that passes, in seconds, between consecutive invocations
 * of the calculate() function.
 */
const float deltaTimeSeconds = 0.02;

/**
 * If the setpoint changes drastically, we can end up with a condition called
 * "integral windup": The error becomes large due to the setpoint change, so
 * the integral term starts calculating huge values that cause our output to
 * overshoot...causing another large error term, another huge integral value,
 * another overshoot, and so an _ad infinitum._
 *
 * There are several practical ways to eliminate this, and one of them is to
 * simply cut the integral term when the error is too large.  Since our
 * outputs are motor speeds between -100 and 100, I'd say a fraction of that
 * interval seems reasonable.
 */
const float maxError = 0.2 * (100 - -100);

/**
 * Sets the PID constants for the Nth PID controller.
 *
 * @param n The index of the controller whose parameters you will be setting.
 *          Values outside of the closed interval [0, MAX_PID_CONTROLLERS - 1]
 *          will be ignored.
 * @param kP Proportional constant.  Used to provide a large amount of power
 *           when there's a long way to go, and a small amount of power as the
 *           measurement gets closer to the setpoint.
 *           (You should probably always have this.)
 * @param kI Integral constant.  Used to slowly increase output power when the
 *           power from the proportional output becomes too small.  Usually
 *           very small compared to kP; set to 0 if you don't need it.
 * @param kD Derivative constant.  Used to slow down if the rate of change in
 *           the error is too fast.  Use 0 if you don't need it.
 *           (I'd suggest setting this before you give kI a nonzero value.)
 */
void setPID(int n, float kP, float kI, float kD) {
  if (n >= 0 && n < MAX_PID_CONTROLLERS) {
    P[n] = kP;
    I[n] = kI;
    D[n] = kD;
    integrals[n] = 0;
    errors[n] = 0;
  }
}

/**
 * Calculates the next output from the PID controller.  The power of the
 * output depends entirely on the constants that you passed into setPID()
 * earlier.
 *
 * @param n	      The index of the controller whose parameters you will be
 *		      setting.  Values outside of the closed interval [0,
 *		      MAX_PID_CONTROLLERS - 1] will be ignored.
 * @param measurement The current measurement for the sensor that you are
 *		      using for PID.  This could be a gyro or potentiometer
 *		      angle, a distance measurement, and so on.
 * @param setpoint    Where you want the measurement to be before we stop
 *		      applying power.
 * @return            Returns the power that your system should be applying
 *		      next.  This is usually a motor speed.
 */
float calculate(int n, float measurement, float setpoint) {
  if (n < 0 || n >= MAX_PID_CONTROLLERS) {
    return 0;
  }

  float error = setpoint - measurement;
  float integral = integrals[n] + error;
  if (error < -maxError || error > maxError) {
    // Avoid integral windup.
    integral = 0;
  }
  float previousError = errors[n];
  float derivative = error - previousError;
  float outputPower = error * P[n] + integral * I[n] + derivative * D[n];

  integrals[n] = integral;
  errors[n] = error;

  return outputPower;
}

enum jointIndices { shoulder, elbow, wrist };

const int SHOULDER_ENCODER_MEASURE_AT_HORIZONTAL = 26;
const int SHOULDER_ENCODER_MEASURE_AT_VERTICAL = 0;

// This is a rough approximation, but it should be the same for every
// quadrature encoder connected to an output shaft.
const float degreesPerEncoderClick = 90.0 / (SHOULDER_ENCODER_MEASURE_AT_HORIZONTAL - SHOULDER_ENCODER_MEASURE_AT_VERTICAL);

// TODO: Measure these values.  They must be measured from axle to axle.
const float forearmLengthInches = 14.0;
const float upperArmLengthInches = 10.0;

// The debugger can't show local variables, but it can show the value of global ones.  So any variable here
// is significant for debugging.
float shoulderPower = 0,
      elbowPower = 0,
      wristPower = 0;

// NOTE: All values here are assumed to be 0 degrees at vertical.  Aim the arm straight up before
// starting the program.
float shoulderDegrees = 0,
      elbowDegrees = 0,
      wristDegrees = 0,
      xInches = 0,
      yInches = forearmLengthInches + upperArmLengthInches;

// How much the buttons move the X and Y values for the arm.
const float armIncrementInches = 1.0;

task main()
{
	// TODO: Determine these constants.
	// Start with the wrist; it's the lightest and problems with it will do the
	// least harm.
	setPID(shoulder, 0, 0, 0);
	setPID(elbow,    0, 0, 0);
	setPID(wrist,    0, 0, 0);

	// Version 2 of the robot arm: all movements are controlled using
	// PID.  We determine two values: X, which is the desired extent
	// outward, and Y, which is the desired vertical extent, and rotate
	// the shoulder and arm motors to reach (x, y).  The wrist, meanwhile,
	// is forced to constantly point at a horizontal angle.
	//
	// The up and down buttons control Y, and the left and right buttons
	// control X.
	while (1) {
		float newX = xInches, newY = yInches;

		if (SensorValue[DownButton]) {
			newY = yInches - armIncrementInches;
		}

		if (SensorValue[UpButton]) {
			newY = yInches + armIncrementInches;
		}

		if (SensorValue[LeftButton]) {
			newX = xInches - armIncrementInches;
		}

		if (SensorValue[RightButton]) {
			newX = xInches + armIncrementInches;
		}

		float h = sqrt(newX * newX + newY * newY);
		if (h < fabs(forearmLengthInches - upperArmLengthInches) ||
		    h > forearmLengthInches + upperArmLengthInches) {
			// You've stretched too far or squeezed the elbow too tight; ignore!
			newX = xInches;
			newY = yInches;
		}

		// Calculate trig constants (all values are in radians.)
		float gamma = acos((h * h - forearmLengthInches * forearmLengthInches - upperArmLengthInches * upperArmLengthInches) /
				   (-2 * forearmLengthInches * upperArmLengthInches));
		float alpha = asin(forearmLengthInches * sin(gamma) / h);
		float beta = PI - alpha - gamma;
		float theta = asin(newY / h);
		float phi = asin(newX / h);

		// 0 degrees for the shoulder and elbow must be vertical.
		float shoulderAngle = (alpha + theta) * RADIANS_TO_DEGREES - 90;
		float elbowAngle = 180 - gamma * RADIANS_TO_DEGREES;

		// The wrist must always face forward.
		float wristAngle = (beta + phi) * RADIANS_TO_DEGREES + 90;

		// Move according to the velocity.
		shoulderPower = calculate(shoulder, SensorValue[ShoulderEncoderA], shoulderAngle);
		elbowPower = calculate(elbow, SensorValue[ElbowEncoderA], elbowAngle);
		wristPower = calculate(wrist, SensorValue[WristEncoderA], wristAngle);
		motor[ShoulderMotor] = shoulderPower;
		motor[ElbowMotor] = elbowPower;
		motor[WristMotor] = wristPower;
	  }

	  // Update angle measures.
	  shoulderDegrees = SensorValue[ShoulderEncoderA] * degreesPerEncoderClick;
	  elbowDegrees = SensorValue[ElbowEncoderA] * degreesPerEncoderClick;
}
